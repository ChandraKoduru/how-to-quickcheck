{-# LANGUAGE OverloadedStrings #-}

module Base64Test where

import Data.Char (ord)
import Data.Monoid ((<>))
import Test.QuickCheck.Instances ()
import Test.Tasty ()
import Test.QuickCheck (quickCheck, collect, Property
  , classify, cover, Gen, scale, forAll, arbitrary
  , (==>), choose, elements, listOf, vectorOf)

import qualified Data.ByteString as BL
import qualified Data.Set as S
import Codec.Binary.Base64 (encode, decode)
import Text.Regex.Posix ((=~))
import GHC.Word (Word8)

prop_sizeRatio :: BL.ByteString -> Bool
prop_sizeRatio b =
  BL.length (encode b) == 4 * ceiling ((fromIntegral (BL.length b) / 3) :: Double)

prop_endsWithPadding :: BL.ByteString -> Property
prop_endsWithPadding b =
  collect suffix $
  (encB =~ ("(^|[^=])" <> suffix <> "$"))              -- at end
    && not (encB =~ ("=[^=]" :: BL.ByteString))        -- only at end
  where
    encB :: BL.ByteString
    encB = encode b
    remainder :: Int
    remainder = fromIntegral $ BL.length b `rem` 3
    suffix :: BL.ByteString
    suffix = BL.replicate ((3 - remainder) `rem` 3) (fromIntegral $ ord '=')

prop_outputAlphabet :: BL.ByteString -> Property
prop_outputAlphabet b =
  cover (S.size used >= 63) 2 "cover full alphabet" -- fails if condition  (>= 63) is not met 2% times
  $ classify (S.size used >= 32) "half-alphabet"  -- accumulates the distribution
  $ classify (S.size used >= 63) "full-alphabet" -- accumulates the distribution
  $ used `S.isSubsetOf` allowed
  where
    used = S.fromList . BL.unpack $ encode b
    allowed = S.fromList . map (fromIntegral . ord) $
      ['A'..'Z'] <> ['a'..'z'] <> ['0'..'9'] <> ['+', '/', '=']

prop_simple_outputAlphabet :: BL.ByteString -> Bool
prop_simple_outputAlphabet b =
  used `S.isSubsetOf` allowed
  where
    used = S.fromList . BL.unpack $ encode b
    allowed = S.fromList . map (fromIntegral . ord) $
      ['A'..'Z'] <> ['a'..'z'] <> ['0'..'9'] <> ['+', '/', '=']

-- Using scale to scale up the arbitrary instances that are generated by default
-- Using forAll to use the scaled/custom generator to build a property
prop_outputAlphabet_with_scaledTestInput :: Property
prop_outputAlphabet_with_scaledTestInput = 
  forAll (scale (*3) (arbitrary :: Gen BL.ByteString)) prop_outputAlphabet

-- property that confirms that decode of encode works
prop_decodeOfEncode :: BL.ByteString -> Bool
prop_decodeOfEncode b = 
  Right b == decode (encode b)

-- property that checks that encode of decode also works
prop_encodeOfDecode :: BL.ByteString -> Property
prop_encodeOfDecode b =
  legit ==> b == encodeEither dec
  where
    dec :: Either (BL.ByteString, BL.ByteString) BL.ByteString
    dec = decode b

    legit :: Bool
    legit = isRight dec

    encodeEither :: Either (BL.ByteString, BL.ByteString) BL.ByteString -> BL.ByteString
    encodeEither (Right x) = encode x
    encodeEither (Left _) = error "Error: extracting Right from Either that is a Left."

isRight :: Either a b -> Bool
isRight (Right _) = True
isRight _ = False

-- Building a custom generator for valid 'encoded input' to feed to decoder
encodedBase64 :: Gen BL.ByteString
encodedBase64 = do
  body <- concat <$> listOf (group 0)
  end <- group =<< choose (0, 2)
  return $ BL.pack $ body <> end
  where
    group :: Int -> Gen [Word8]
    group pad = do
      letters <- vectorOf (4 - pad)
        . elements . map (fromIntegral . ord)
        $ ['A'..'Z'] <> ['a'..'z'] <> ['O'..'9'] <> ['+', '/', '=']
      return $ letters <> replicate pad 61

prop_encodeOfDecode_using_encodedBase64_generator :: Property
prop_encodeOfDecode_using_encodedBase64_generator =
  forAll encodedBase64 prop_encodeOfDecode

main :: IO ()
main = do
  quickCheck prop_sizeRatio
  quickCheck prop_endsWithPadding
  quickCheck prop_outputAlphabet
  quickCheck prop_simple_outputAlphabet
  quickCheck prop_outputAlphabet_with_scaledTestInput
  quickCheck prop_decodeOfEncode
  quickCheck prop_encodeOfDecode
  quickCheck prop_encodeOfDecode_using_encodedBase64_generator

main1 :: IO ()
main1 = main
